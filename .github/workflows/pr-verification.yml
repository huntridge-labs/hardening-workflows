name: PR Verification - Test Scanner Controls

on:
  pull_request:
    branches: [main]

permissions:
  contents: read
  security-events: write
  pull-requests: write
  checks: write

jobs:
  # Detect which scanner workflows have changed
  detect-changes:
    name: Detect Changed Scanners
    runs-on: ubuntu-latest
    outputs:
      scanner_codeql: ${{ steps.filter.outputs.scanner_codeql }}
      scanner_opengrep: ${{ steps.filter.outputs.scanner_opengrep }}
      scanner_bandit: ${{ steps.filter.outputs.scanner_bandit }}
      scanner_gitleaks: ${{ steps.filter.outputs.scanner_gitleaks }}
      scanner_syft: ${{ steps.filter.outputs.scanner_syft }}
      scanner_trivy_iac: ${{ steps.filter.outputs.scanner_trivy_iac }}
      scanner_checkov: ${{ steps.filter.outputs.scanner_checkov }}
      scanner_trivy_container: ${{ steps.filter.outputs.scanner_trivy_container }}
      scanner_grype: ${{ steps.filter.outputs.scanner_grype }}
      reusable_workflow: ${{ steps.filter.outputs.reusable_workflow }}
      any_scanner: ${{ steps.filter.outputs.any_scanner }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            scanner_codeql:
              - '.github/workflows/scanner-codeql.yml'
            scanner_opengrep:
              - '.github/workflows/scanner-opengrep.yml'
            scanner_bandit:
              - '.github/workflows/scanner-bandit.yml'
            scanner_gitleaks:
              - '.github/workflows/scanner-gitleaks.yml'
            scanner_syft:
              - '.github/workflows/scanner-syft.yml'
            scanner_trivy_iac:
              - '.github/workflows/scanner-trivy-iac.yml'
            scanner_checkov:
              - '.github/workflows/scanner-checkov.yml'
            scanner_trivy_container:
              - '.github/workflows/scanner-trivy-container.yml'
            scanner_grype:
              - '.github/workflows/scanner-grype.yml'
            reusable_workflow:
              - '.github/workflows/reusable-security-hardening.yml'
              - '.github/workflows/pr-reusable-security-hardening.yml'
            any_scanner:
              - '.github/workflows/scanner-*.yml'

  # Validate PR and production reusable workflows stay in sync
  validate-workflow-sync:
    name: Validate Workflow Sync
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.reusable_workflow == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Check workflows are in sync
        run: .github/scripts/validate-reusable-workflow-sync.sh

  # Run code quality checks once for all tests
  code-quality:
    name: Code Quality & Linting
    uses: ./.github/workflows/linting.yml
    permissions:
      contents: read
      pull-requests: write
      checks: write

  gitleaks-scan:
    name: Gitleaks Scan
    needs: code-quality
    uses: ./.github/workflows/scanner-gitleaks.yml
    with:
      post_pr_comment: false
      enable_code_security: false
    permissions:
      contents: read
      security-events: write
      actions: read
      pull-requests: write

  # Test scanner resolution logic directly
  test-scanner-resolution:
    name: Test Scanner Resolution Logic
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        test:
          - name: 'codeql-only'
            scanners: 'codeql'
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'
            expect_sbom: 'false'
          - name: 'sast-scanners'
            scanners: 'codeql,opengrep,bandit,gitleaks'
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'true'
            expect_gitleaks: 'true'
            expect_container: 'false'
            expect_infrastructure: 'false'
            expect_sbom: 'false'
          - name: 'container-only'
            scanners: 'container'
            expect_codeql: 'false'
            expect_opengrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'true'
            expect_infrastructure: 'false'
            expect_sbom: 'false'
          - name: 'infrastructure-only'
            scanners: 'infrastructure'
            expect_codeql: 'false'
            expect_opengrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'true'
            expect_sbom: 'false'
          - name: 'sbom-only'
            scanners: 'sbom'
            expect_codeql: 'false'
            expect_opengrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'
            expect_sbom: 'true'
          - name: 'all-scanners'
            scanners: 'all'
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'true'
            expect_gitleaks: 'true'
            expect_container: 'true'
            expect_infrastructure: 'true'
            expect_sbom: 'true'
          - name: 'empty-defaults'
            scanners: ''
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'true'
            expect_gitleaks: 'true'
            expect_container: 'true'
            expect_infrastructure: 'true'
            expect_sbom: 'true'
          - name: 'codeql-disabled-by-code-security'
            scanners: 'codeql'
            enable_code_security: 'false'
            expect_codeql: 'false'
            expect_opengrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'
            expect_sbom: 'false'

    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Test scanner resolution logic
      run: |
        echo "Testing scanners input: ${{ matrix.test.scanners }}"

        # Simulate the scanner resolution logic from reusable-security-hardening.yml
        SCANNERS="${{ matrix.test.scanners }}"
        echo "Input scanners: $SCANNERS"

        # Parse scanners (same logic as in the main workflow)
        declare -A RUN=(
          [codeql]=false
          [opengrep]=false
          [bandit]=false
          [gitleaks]=false
          [container]=false
          [infrastructure]=false
          [sbom]=false
        )

        DEFAULT_SCANNERS=(codeql opengrep bandit gitleaks container infrastructure sbom)
        SELECTED=()

        normalize() {
          echo "$1" | tr '[:upper:]' '[:lower:]' | tr -d ' \t' | tr '_' '-'
        }

        add_scanner() {
          local key="$1"
          if [[ -z "${RUN[$key]+_}" ]]; then
            echo "Warning: Unknown scanner '$key' ignored"
            return
          fi
          RUN[$key]=true
          SELECTED+=("$key")
        }

        # Process scanner input
        if [[ -z "$SCANNERS" ]]; then
          # Empty input = run all default scanners
          for scanner in "${DEFAULT_SCANNERS[@]}"; do
            add_scanner "$scanner"
          done
        else
          # Parse comma-separated list
          IFS=',' read -ra TOKENS <<< "$SCANNERS"
          for token in "${TOKENS[@]}"; do
            token=$(normalize "$token")
            case "$token" in
              all)
                # 'all' = run all default scanners
                for scanner in "${DEFAULT_SCANNERS[@]}"; do
                  add_scanner "$scanner"
                done
                break
                ;;
              semgrep|opengrep|open-grep)
                add_scanner opengrep
                ;;
              *)
                add_scanner "$token"
                ;;
            esac
          done
        fi

        # Check GitHub Code Security integration (same as main workflow)
        ENABLE_CODE_SECURITY="${{ matrix.test.enable_code_security }}"
        if [[ "${RUN[codeql]}" == "true" && "$ENABLE_CODE_SECURITY" != "true" ]]; then
          echo "CodeQL disabled due to Code Security integration not enabled"
          RUN[codeql]=false
          # Remove codeql from SELECTED array
          SELECTED=("${SELECTED[@]/codeql}")
        fi

        # Verify expectations
        echo "Expected CodeQL: ${{ matrix.test.expect_codeql }}, Got: ${RUN[codeql]}"
        echo "Expected OpenGrep: ${{ matrix.test.expect_opengrep }}, Got: ${RUN[opengrep]}"
        echo "Expected Bandit: ${{ matrix.test.expect_bandit }}, Got: ${RUN[bandit]}"
        echo "Expected Gitleaks: ${{ matrix.test.expect_gitleaks }}, Got: ${RUN[gitleaks]}"
        echo "Expected Container: ${{ matrix.test.expect_container }}, Got: ${RUN[container]}"
        echo "Expected Infrastructure: ${{ matrix.test.expect_infrastructure }}, Got: ${RUN[infrastructure]}"
        echo "Expected SBOM: ${{ matrix.test.expect_sbom }}, Got: ${RUN[sbom]}"

        FAILED=false

        if [ "${RUN[codeql]}" != "${{ matrix.test.expect_codeql }}" ]; then
          echo "âŒ CodeQL mismatch"
          FAILED=true
        fi

        if [ "${RUN[opengrep]}" != "${{ matrix.test.expect_opengrep }}" ]; then
          echo "âŒ OpenGrep mismatch"
          FAILED=true
        fi

        if [ "${RUN[bandit]}" != "${{ matrix.test.expect_bandit }}" ]; then
          echo "âŒ Bandit mismatch"
          FAILED=true
        fi

        if [ "${RUN[gitleaks]}" != "${{ matrix.test.expect_gitleaks }}" ]; then
          echo "âŒ Gitleaks mismatch"
          FAILED=true
        fi

        if [ "${RUN[container]}" != "${{ matrix.test.expect_container }}" ]; then
          echo "âŒ Container mismatch"
          FAILED=true
        fi

        if [ "${RUN[infrastructure]}" != "${{ matrix.test.expect_infrastructure }}" ]; then
          echo "âŒ Infrastructure mismatch"
          FAILED=true
        fi

        if [ "${RUN[sbom]}" != "${{ matrix.test.expect_sbom }}" ]; then
          echo "âŒ SBOM mismatch"
          FAILED=true
        fi

        if [ "$FAILED" = true ]; then
          echo "::error title=Scanner Resolution Test Failed::Scanners input '${{ matrix.test.scanners }}' produced unexpected results"
          exit 1
        fi

        echo "âœ… Scanner resolution for '${{ matrix.test.scanners }}' verified"

  # Test scanners input validation and edge cases
  test-scanners-input-validation:
    name: Test Scanners Input Validation
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        test:
          - name: 'mixed-case-scanners'
            scanners: 'CodeQL,OPENGREP,BanDit'
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'true'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'
          - name: 'whitespace-handling'
            scanners: ' codeql , opengrep , bandit '
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'true'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'
          - name: 'duplicate-scanners'
            scanners: 'codeql,codeql,opengrep,opengrep'
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'
          - name: 'unknown-scanner-ignored'
            scanners: 'codeql,unknown_scanner,opengrep'
            enable_code_security: 'true'
            expect_codeql: 'true'
            expect_opengrep: 'true'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
            expect_container: 'false'
            expect_infrastructure: 'false'

    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Test scanners input validation
      run: |
        echo "Testing scanners input validation: ${{ matrix.test.name }}"
        echo "Input: ${{ matrix.test.scanners }}"

        # Use the same scanner resolution logic
        SCANNERS="${{ matrix.test.scanners }}"
        echo "Input scanners: $SCANNERS"

        declare -A RUN=(
          [codeql]=false
          [opengrep]=false
          [bandit]=false
          [gitleaks]=false
          [container]=false
          [infrastructure]=false
          [sbom]=false
        )

        DEFAULT_SCANNERS=(codeql opengrep bandit gitleaks container infrastructure sbom)
        SELECTED=()

        normalize() {
          echo "$1" | tr '[:upper:]' '[:lower:]' | tr -d ' \t' | tr '_' '-'
        }

        add_scanner() {
          local key="$1"
          if [[ -z "${RUN[$key]+_}" ]]; then
            echo "Warning: Unknown scanner '$key' ignored"
            return
          fi
          RUN[$key]=true
          SELECTED+=("$key")
        }

        # Process scanner input
        if [[ -z "$SCANNERS" ]]; then
          for scanner in "${DEFAULT_SCANNERS[@]}"; do
            add_scanner "$scanner"
          done
        else
          IFS=',' read -ra TOKENS <<< "$SCANNERS"
          for token in "${TOKENS[@]}"; do
            token=$(normalize "$token")
            case "$token" in
              all)
                for scanner in "${DEFAULT_SCANNERS[@]}"; do
                  add_scanner "$scanner"
                done
                break
                ;;
              semgrep|opengrep|open-grep)
                add_scanner opengrep
                ;;
              *)
                add_scanner "$token"
                ;;
            esac
          done
        fi

        # Check GitHub Code Security integration (same as main workflow)
        ENABLE_CODE_SECURITY="${{ matrix.test.enable_code_security }}"
        if [[ "${RUN[codeql]}" == "true" && "$ENABLE_CODE_SECURITY" != "true" ]]; then
          echo "CodeQL disabled due to Code Security integration not enabled"
          RUN[codeql]=false
          # Remove codeql from SELECTED array
          SELECTED=("${SELECTED[@]/codeql}")
        fi

        # Verify expectations
        FAILED=false

        if [ "${RUN[codeql]}" != "${{ matrix.test.expect_codeql }}" ]; then
          echo "âŒ CodeQL mismatch: expected ${{ matrix.test.expect_codeql }}, got ${RUN[codeql]}"
          FAILED=true
        fi

        if [ "${RUN[opengrep]}" != "${{ matrix.test.expect_opengrep }}" ]; then
          echo "âŒ OpenGrep mismatch: expected ${{ matrix.test.expect_opengrep }}, got ${RUN[opengrep]}"
          FAILED=true
        fi

        if [ "${RUN[bandit]}" != "${{ matrix.test.expect_bandit }}" ]; then
          echo "âŒ Bandit mismatch: expected ${{ matrix.test.expect_bandit }}, got ${RUN[bandit]}"
          FAILED=true
        fi

        if [ "${RUN[gitleaks]}" != "${{ matrix.test.expect_gitleaks }}" ]; then
          echo "âŒ Gitleaks mismatch: expected ${{ matrix.test.expect_gitleaks }}, got ${RUN[gitleaks]}"
          FAILED=true
        fi

        if [ "${RUN[container]}" != "${{ matrix.test.expect_container }}" ]; then
          echo "âŒ Container mismatch: expected ${{ matrix.test.expect_container }}, got ${RUN[container]}"
          FAILED=true
        fi

        if [ "${RUN[infrastructure]}" != "${{ matrix.test.expect_infrastructure }}" ]; then
          echo "âŒ Infrastructure mismatch: expected ${{ matrix.test.expect_infrastructure }}, got ${RUN[infrastructure]}"
          FAILED=true
        fi

        if [ "$FAILED" = true ]; then
          echo "::error title=Scanners Input Validation Test Failed::Test '${{ matrix.test.name }}' failed validation"
          exit 1
        fi

        echo "âœ… Scanners input validation test '${{ matrix.test.name }}' passed"

  # Test individual scanners directly with relative paths to verify branch changes
  # These only run if the corresponding scanner workflow was modified
  # Note: Using pr-reusable-security-hardening.yml which tests ALL scanners with branch versions

  # Integration test - run the PR testing version of reusable workflow
  # This uses relative paths for ALL scanner workflows to test branch changes
  integration-test-full-scan:
    name: Integration Test - Full Scan (Branch Versions)
    needs: [detect-changes, code-quality, test-scanner-resolution, test-scanners-input-validation]
    if: needs.detect-changes.outputs.any_scanner == 'true' || needs.detect-changes.outputs.reusable_workflow == 'true'
    uses: ./.github/workflows/pr-reusable-security-hardening.yml
    with:
      scanners: 'all'  # Test all scanners with branch versions
      codeql_languages: 'python,javascript'
      enable_code_security: true
      post_pr_comment: true
    permissions:
      contents: read
      security-events: write
      pull-requests: write
      checks: write
      actions: read
      id-token: write
    secrets: inherit

  # Verification Summary
  verification-summary:
    name: PR Verification Summary
    runs-on: ubuntu-latest
    needs: [
      detect-changes,
      code-quality,
      test-scanner-resolution,
      test-scanners-input-validation,
      integration-test-full-scan
    ]
    if: always()

    steps:
    - name: Check test results
      run: |
        echo "# ðŸ§ª PR Verification Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Testing reusable security hardening workflow..." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Show which scanners were changed and tested
        echo "## ðŸ“¦ Changed Scanners Detected" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        CHANGED_COUNT=0
        if [ "${{ needs.detect-changes.outputs.scanner_codeql }}" = "true" ]; then
          echo "- âœï¸ **CodeQL** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_opengrep }}" = "true" ]; then
          echo "- âœï¸ **Opengrep** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_bandit }}" = "true" ]; then
          echo "- âœï¸ **Bandit** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_gitleaks }}" = "true" ]; then
          echo "- âœï¸ **Gitleaks** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_syft }}" = "true" ]; then
          echo "- âœï¸ **Syft** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_trivy_iac }}" = "true" ]; then
          echo "- âœï¸ **Trivy IaC** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_checkov }}" = "true" ]; then
          echo "- âœï¸ **Checkov** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_trivy_container }}" = "true" ]; then
          echo "- âœï¸ **Trivy Container** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.scanner_grype }}" = "true" ]; then
          echo "- âœï¸ **Grype** scanner modified (tested with branch version)" >> $GITHUB_STEP_SUMMARY
          CHANGED_COUNT=$((CHANGED_COUNT + 1))
        fi
        if [ "${{ needs.detect-changes.outputs.reusable_workflow }}" = "true" ]; then
          echo "- âœï¸ **Reusable workflow** modified" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$CHANGED_COUNT" -eq 0 ]; then
          echo "_No scanner workflows modified in this PR_" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY

        # Check each test result
        LINTING="${{ needs.code-quality.result }}"
        SCANNER_RESOLUTION="${{ needs.test-scanner-resolution.result }}"
        INPUT_VALIDATION="${{ needs.test-scanners-input-validation.result }}"
        INTEGRATION_FULL="${{ needs.integration-test-full-scan.result }}"

        echo "## ðŸ“Š Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Test | Result |" >> $GITHUB_STEP_SUMMARY
        echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

        if [ "$LINTING" = "success" ]; then
          echo "| âœ… Code Quality & Linting | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| âŒ Code Quality & Linting | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$SCANNER_RESOLUTION" = "success" ]; then
          echo "| âœ… Scanner Resolution Logic (6 scenarios) | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| âŒ Scanner Resolution Logic (6 scenarios) | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$INPUT_VALIDATION" = "success" ]; then
          echo "| âœ… Scanners Input Validation (4 edge cases) | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| âŒ Scanners Input Validation (4 edge cases) | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        # Integration test - tests ALL scanners with branch versions
        if [ "${{ needs.detect-changes.outputs.any_scanner }}" = "true" ] || [ "${{ needs.detect-changes.outputs.reusable_workflow }}" = "true" ]; then
          RESULT="${{ needs.integration-test-full-scan.result }}"
          if [ "$RESULT" = "success" ]; then
            echo "| âœ… Integration Test - All Scanners (Branch Versions) | Passed |" >> $GITHUB_STEP_SUMMARY
          elif [ "$RESULT" = "skipped" ]; then
            echo "| â­ï¸  Integration Test - All Scanners | Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| âŒ Integration Test - All Scanners (Branch Versions) | $RESULT |" >> $GITHUB_STEP_SUMMARY
          fi
        fi

        echo "" >> $GITHUB_STEP_SUMMARY

        # Calculate pass rate (core tests only - scanner tests are conditional)
        TOTAL=3
        PASSED=0
        [ "$LINTING" = "success" ] && PASSED=$((PASSED + 1))
        [ "$SCANNER_RESOLUTION" = "success" ] && PASSED=$((PASSED + 1))
        [ "$INPUT_VALIDATION" = "success" ] && PASSED=$((PASSED + 1))

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "## ðŸ“ Summary" >> $GITHUB_STEP_SUMMARY
        echo "**$PASSED of $TOTAL core test suites passed**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Test Coverage:" >> $GITHUB_STEP_SUMMARY
        echo "- **Code Quality & Linting**: Validates code style and quality (always runs)" >> $GITHUB_STEP_SUMMARY
        echo "- **Scanner Resolution Logic**: 6 test scenarios validating scanner selection (always runs)" >> $GITHUB_STEP_SUMMARY
        echo "- **Input Validation**: 4 edge cases - case sensitivity, whitespace, duplicates, unknowns (always runs)" >> $GITHUB_STEP_SUMMARY
        echo "- **Full Integration Test**: Tests ALL scanners with branch versions when any scanner or reusable workflow is modified" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "> **Solution**: Uses \`pr-reusable-security-hardening.yml\` which is identical to the production workflow " >> $GITHUB_STEP_SUMMARY
        echo "> but with relative paths instead of pinned tags. This allows complete testing of all scanner changes " >> $GITHUB_STEP_SUMMARY
        echo "> while staying within GitHub's 20 reusable workflow limit. External consumers continue using the " >> $GITHUB_STEP_SUMMARY
        echo "> stable \`reusable-security-hardening.yml\` with pinned versions." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ $PASSED -eq $TOTAL ]; then
          echo "âœ… All verification tests passed! The reusable workflow is working correctly." >> $GITHUB_STEP_SUMMARY
          echo "::notice title=PR Verification::All $TOTAL test suites passed"
          exit 0
        else
          FAILED=$((TOTAL - PASSED))
          echo "âŒ $FAILED test suite(s) failed. Please review the workflow logs." >> $GITHUB_STEP_SUMMARY
          echo "::error title=PR Verification::$FAILED of $TOTAL test suites failed"
          exit 1
        fi

    - name: Comment PR with verification results
      if: always() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
      uses: actions/github-script@v8
      with:
        script: |
          const results = {
            'Code Quality & Linting': '${{ needs.code-quality.result }}',
            'Scanner Resolution Logic (6 scenarios)': '${{ needs.test-scanner-resolution.result }}',
            'Scanners Input Validation (4 edge cases)': '${{ needs.test-scanners-input-validation.result }}',
            'Integration Test - Full Scan': '${{ needs.integration-test-full-scan.result }}'
          };

          let passed = 0;
          let total = Object.keys(results).length;

          let table = '| Test Suite | Result |\n|------------|--------|\n';
          for (const [test, result] of Object.entries(results)) {
            const icon = result === 'success' ? 'âœ…' : 'âŒ';
            const status = result === 'success' ? 'Passed' : 'Failed';
            table += `| ${icon} ${test} | ${status} |\n`;
            if (result === 'success') passed++;
          }

          const summary = passed === total
            ? `âœ… All ${total} test suites passed!`
            : `âš ï¸ ${passed}/${total} test suites passed. ${total - passed} suite(s) failed.`;

          const body = `## ðŸ§ª Reusable Workflow Verification Results\n\n${summary}\n\n${table}\n\n### Test Coverage\n- **Code Quality & Linting** - Validates code style and quality\n- **Scanner Resolution Logic** - 6 test scenarios validating scanner selection\n- **Input Validation** - 4 edge cases (case sensitivity, whitespace, duplicates, unknowns)\n- **Full Integration Test** - End-to-end test with SAST, Container, and Infrastructure scanners + PR comment generation\n\n---\n*Verification run for commit ${context.sha.substring(0, 7)}*`;

          // Find existing comment
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });

          const existingComment = comments.data.find(comment =>
            comment.body.includes('Reusable Workflow Verification Results') &&
            comment.user.login === 'github-actions[bot]'
          );

          if (existingComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }

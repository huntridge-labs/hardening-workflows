name: PR Verification - Test Scanner Controls

on:
  pull_request:
    branches: [main]
    paths:
      - '.github/workflows/reusable-security-hardening.yml'
      - '.github/workflows/sast.yml'
      - '.github/workflows/container-scan.yml'
      - '.github/workflows/scanners/**'
      - '.github/workflows/pr-verification.yml'

permissions:
  contents: read
  security-events: write
  pull-requests: write
  checks: write

jobs:
  # Run code quality checks once for all tests
  code-quality:
    name: Code Quality & Linting
    uses: ./.github/workflows/linting.yml
    permissions:
      contents: read
      pull-requests: write
      checks: write

  # Test scan coordinator logic directly
  test-scan-coordinator:
    name: Test Scan Coordinator Logic
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        test:
          - name: 'codeql-only'
            scan_type: 'codeql-only'
            expect_codeql: 'true'
            expect_semgrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
          - name: 'sast-only'
            scan_type: 'sast-only'
            expect_codeql: 'true'
            expect_semgrep: 'true'
            expect_bandit: 'true'
            expect_gitleaks: 'true'
          - name: 'container-only'
            scan_type: 'container-only'
            expect_codeql: 'false'
            expect_semgrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'
          - name: 'infrastructure-only'
            scan_type: 'infrastructure-only'
            expect_codeql: 'false'
            expect_semgrep: 'false'
            expect_bandit: 'false'
            expect_gitleaks: 'false'

    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Test scan type logic
      run: |
        echo "Testing scan type: ${{ matrix.test.scan_type }}"

        # Simulate the scan coordinator logic
        SCAN_TYPE="${{ matrix.test.scan_type }}"

        case "$SCAN_TYPE" in
          "full")
            CODEQL=true; SEMGREP=true; BANDIT=true; GITLEAKS=true
            ;;
          "sast-only")
            CODEQL=true; SEMGREP=true; BANDIT=true; GITLEAKS=true
            ;;
          "codeql-only")
            CODEQL=true; SEMGREP=false; BANDIT=false; GITLEAKS=false
            ;;
          "container-only")
            CODEQL=false; SEMGREP=false; BANDIT=false; GITLEAKS=false
            ;;
          "infrastructure-only")
            CODEQL=false; SEMGREP=false; BANDIT=false; GITLEAKS=false
            ;;
        esac

        # Verify expectations
        echo "Expected CodeQL: ${{ matrix.test.expect_codeql }}, Got: $CODEQL"
        echo "Expected Semgrep: ${{ matrix.test.expect_semgrep }}, Got: $SEMGREP"
        echo "Expected Bandit: ${{ matrix.test.expect_bandit }}, Got: $BANDIT"
        echo "Expected Gitleaks: ${{ matrix.test.expect_gitleaks }}, Got: $GITLEAKS"

        FAILED=false

        if [ "$CODEQL" != "${{ matrix.test.expect_codeql }}" ]; then
          echo "❌ CodeQL mismatch"
          FAILED=true
        fi

        if [ "$SEMGREP" != "${{ matrix.test.expect_semgrep }}" ]; then
          echo "❌ Semgrep mismatch"
          FAILED=true
        fi

        if [ "$BANDIT" != "${{ matrix.test.expect_bandit }}" ]; then
          echo "❌ Bandit mismatch"
          FAILED=true
        fi

        if [ "$GITLEAKS" != "${{ matrix.test.expect_gitleaks }}" ]; then
          echo "❌ Gitleaks mismatch"
          FAILED=true
        fi

        if [ "$FAILED" = true ]; then
          echo "::error title=Scan Coordinator Test Failed::Scan type ${{ matrix.test.scan_type }} produced unexpected results"
          exit 1
        fi

        echo "✅ Scan type ${{ matrix.test.scan_type }} logic verified"

  # Test granular enable flags
  test-granular-controls:
    name: Test Granular Enable Flags
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        test:
          - name: 'enable-codeql-only'
            enable_codeql: 'true'
            enable_semgrep: 'false'
            enable_bandit: 'false'
            enable_gitleaks: 'false'
          - name: 'enable-codeql-gitleaks'
            enable_codeql: 'true'
            enable_semgrep: 'false'
            enable_bandit: 'false'
            enable_gitleaks: 'true'
          - name: 'enable-semgrep-bandit'
            enable_codeql: 'false'
            enable_semgrep: 'true'
            enable_bandit: 'true'
            enable_gitleaks: 'false'

    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Test granular enable flags
      run: |
        echo "Testing granular controls: ${{ matrix.test.name }}"

        # Simulate granular override logic
        ENABLE_CODEQL="${{ matrix.test.enable_codeql }}"
        ENABLE_SEMGREP="${{ matrix.test.enable_semgrep }}"
        ENABLE_BANDIT="${{ matrix.test.enable_bandit }}"
        ENABLE_GITLEAKS="${{ matrix.test.enable_gitleaks }}"

        echo "CodeQL: $ENABLE_CODEQL"
        echo "Semgrep: $ENABLE_SEMGREP"
        echo "Bandit: $ENABLE_BANDIT"
        echo "Gitleaks: $ENABLE_GITLEAKS"

        # Verify at least one scanner is enabled
        if [ "$ENABLE_CODEQL" = "false" ] && \
           [ "$ENABLE_SEMGREP" = "false" ] && \
           [ "$ENABLE_BANDIT" = "false" ] && \
           [ "$ENABLE_GITLEAKS" = "false" ]; then
          if [ "${{ matrix.test.name }}" != "all-disabled" ]; then
            echo "❌ At least one scanner should be enabled"
            exit 1
          fi
        fi

        echo "✅ Granular control test ${{ matrix.test.name }} passed"

  # Integration test - run one actual scanner to verify end-to-end
  integration-test-codeql:
    name: Integration Test - CodeQL
    needs: [code-quality, test-scan-coordinator, test-granular-controls]
    uses: ./.github/workflows/reusable-security-hardening.yml
    with:
      scan_type: 'codeql-only'
      codeql_languages: 'python'
      post_pr_comment: false
      skip_linting: true  # Linting already ran in code-quality job
    permissions:
      contents: read
      security-events: write
      pull-requests: write
      checks: write
      actions: read
      id-token: write
    secrets: inherit

  # Verification Summary
  verification-summary:
    name: PR Verification Summary
    runs-on: ubuntu-latest
    needs: [
      code-quality,
      test-scan-coordinator,
      test-granular-controls,
      integration-test-codeql
    ]
    if: always()

    steps:
    - name: Check test results
      run: |
        echo "# 🧪 PR Verification Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Testing scanner control functionality..." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Check each test result
        LINTING="${{ needs.code-quality.result }}"
        COORDINATOR="${{ needs.test-scan-coordinator.result }}"
        GRANULAR="${{ needs.test-granular-controls.result }}"
        INTEGRATION="${{ needs.integration-test-codeql.result }}"

        echo "| Test | Result |" >> $GITHUB_STEP_SUMMARY
        echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

        if [ "$LINTING" = "success" ]; then
          echo "| ✅ Code Quality & Linting | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| ❌ Code Quality & Linting | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$COORDINATOR" = "success" ]; then
          echo "| ✅ Scan Coordinator Logic (4 scan types) | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| ❌ Scan Coordinator Logic (4 scan types) | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$GRANULAR" = "success" ]; then
          echo "| ✅ Granular Enable Controls (3 scenarios) | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| ❌ Granular Enable Controls (3 scenarios) | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        if [ "$INTEGRATION" = "success" ]; then
          echo "| ✅ End-to-End Integration (CodeQL) | Passed |" >> $GITHUB_STEP_SUMMARY
        else
          echo "| ❌ End-to-End Integration (CodeQL) | Failed |" >> $GITHUB_STEP_SUMMARY
        fi

        echo "" >> $GITHUB_STEP_SUMMARY

        # Calculate pass rate
        TOTAL=4
        PASSED=0
        [ "$LINTING" = "success" ] && PASSED=$((PASSED + 1))
        [ "$COORDINATOR" = "success" ] && PASSED=$((PASSED + 1))
        [ "$GRANULAR" = "success" ] && PASSED=$((PASSED + 1))
        [ "$INTEGRATION" = "success" ] && PASSED=$((PASSED + 1))

        echo "## Summary" >> $GITHUB_STEP_SUMMARY
        echo "**$PASSED of $TOTAL test suites passed**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- Code Quality & Linting: 1 test" >> $GITHUB_STEP_SUMMARY
        echo "- Scan Coordinator Logic: 4 test scenarios" >> $GITHUB_STEP_SUMMARY
        echo "- Granular Enable Controls: 3 test scenarios" >> $GITHUB_STEP_SUMMARY
        echo "- End-to-End Integration: 1 full scanner run" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        if [ $PASSED -eq $TOTAL ]; then
          echo "✅ All scanner control features are working correctly!" >> $GITHUB_STEP_SUMMARY
          echo "::notice title=PR Verification::All $TOTAL test suites passed (9 total scenarios)"
          exit 0
        else
          FAILED=$((TOTAL - PASSED))
          echo "❌ $FAILED test suite(s) failed. Please review the workflow logs." >> $GITHUB_STEP_SUMMARY
          echo "::error title=PR Verification::$FAILED of $TOTAL test suites failed"
          exit 1
        fi

    - name: Comment PR with verification results
      if: always() && github.event_name == 'pull_request'
      uses: actions/github-script@v8
      with:
        script: |
          const results = {
            'Code Quality & Linting': '${{ needs.code-quality.result }}',
            'Scan Coordinator Logic (4 scenarios)': '${{ needs.test-scan-coordinator.result }}',
            'Granular Enable Controls (3 scenarios)': '${{ needs.test-granular-controls.result }}',
            'End-to-End Integration (CodeQL)': '${{ needs.integration-test-codeql.result }}'
          };

          let passed = 0;
          let total = Object.keys(results).length;

          let table = '| Test Suite | Result |\n|------------|--------|\n';
          for (const [test, result] of Object.entries(results)) {
            const icon = result === 'success' ? '✅' : '❌';
            const status = result === 'success' ? 'Passed' : 'Failed';
            table += `| ${icon} ${test} | ${status} |\n`;
            if (result === 'success') passed++;
          }

          const summary = passed === total
            ? `✅ All ${total} test suites passed (9 total scenarios)!`
            : `⚠️ ${passed}/${total} test suites passed. ${total - passed} suite(s) failed.`;

          const body = `## 🧪 Scanner Control Verification Results\n\n${summary}\n\n${table}\n\n### Test Coverage\n- **Linting runs once** - Code quality checks before all tests\n- **4 scan type scenarios** - Validates scan_type parameter logic\n- **3 granular control scenarios** - Validates enable_* parameter combinations\n- **1 end-to-end test** - Full workflow execution with actual scanner\n\n---\n*Verification run for commit ${context.sha.substring(0, 7)}*`;

          // Find existing comment
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });

          const existingComment = comments.data.find(comment =>
            comment.body.includes('Scanner Control Verification Results') &&
            comment.user.login === 'github-actions[bot]'
          );

          if (existingComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: body
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
          }
